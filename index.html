<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kana Quiz</title>
  <link href="./output.css" rel="stylesheet">
</head>

<body class="bg-gray-900 text-gray-100 min-h-screen">
  <div class="max-w-3xl mx-auto p-6">
    <header class="mb-6 text-center">
      <h1 class="text-3xl font-bold">Kana Quiz</h1>
      <p class="text-sm text-gray-400">Hiragana • Katakana • Romaji</p>
    </header>

    <!-- Main Menu -->
    <section id="mainMenu" class="space-y-6">
      <!-- Quiz Type -->
      <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
        <h2 class="text-xl font-semibold mb-3">Quiz Type</h2>
        <div class="grid sm:grid-cols-2 gap-3">
          <label class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="radio" name="quizType" value="mixedToRoma" class="w-4 h-4" checked>
            <span>Mixed Kana (ひ/カ) ➜ Romaji</span>
          </label>
          <label
            class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer sm:col-start-1 sm:row-start-2">
            <input type="radio" name="quizType" value="kataToRoma" class="w-4 h-4">
            <span>Katakana ➜ Romaji</span>
          </label>
          <label
            class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer sm:col-start-2 sm:row-start-2">
            <input type="radio" name="quizType" value="hiraToRoma" class="w-4 h-4">
            <span>Hiragana ➜ Romaji</span>
          </label>
          <label
            class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer sm:col-start-1 sm:row-start-3">
            <input type="radio" name="quizType" value="kataToHira" class="w-4 h-4">
            <span>Katakana ➜ Hiragana</span>
          </label>
          <label
            class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer sm:col-start-2 sm:row-start-3">
            <input type="radio" name="quizType" value="hiraToKata" class="w-4 h-4">
            <span>Hiragana ➜ Katakana</span>
          </label>
          <label
            class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer sm:col-start-1 sm:row-start-4">
            <input type="radio" name="quizType" value="romaToKata" class="w-4 h-4">
            <span>Romaji ➜ Katakana</span>
          </label>
          <label
            class="flex items-center gap-3 border border-gray-700 rounded-xl p-3 cursor-pointer sm:col-start-2 sm:row-start-4">
            <input type="radio" name="quizType" value="romaToHira" class="w-4 h-4">
            <span>Romaji ➜ Hiragana</span>
          </label>

        </div>

        <!-- Answer Mode -->
        <div class="mt-4">
          <h2 class="text-xl font-semibold mb-2">Answer Mode</h2>
          <div class="grid sm:grid-cols-3 gap-3">
            <label id="modeTextLabel"
              class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
              <input type="radio" name="answerMode" value="text" id="answerModeText" class="w-4 h-4">
              <span>Typing</span>
            </label>
            <label id="modeMCLabel"
              class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
              <input type="radio" name="answerMode" value="mc" id="answerModeMC" class="w-4 h-4" checked>
              <span>Multiple Choice</span>
            </label>
            <label id="modeDrawLabel"
              class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
              <input type="radio" name="answerMode" value="draw" id="answerModeDraw" class="w-4 h-4">
              <span>Drawing</span>
            </label>
          </div>

          <!-- Distractor pool toggle (for Kana MC only) -->
          <div id="distractorRow" class="mt-4">
            <label id="distractorLabel" class="flex items-center gap-2 border border-gray-700 rounded-xl p-3">
              <input type="checkbox" id="distractorSelectedOnly" class="w-4 h-4" />
              <span>Only use selected character pools for kana distractors (still both scripts)</span>
            </label>
            <p class="text-xs text-gray-500 mt-2">
              When unchecked (default), kana distractors come from all kana (hiragana + katakana).
            </p>
          </div>
        </div>
      </div>

      <!-- Character Pools -->
      <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
        <h2 class="text-xl font-semibold mb-3">Character Pools</h2>
        <p class="text-sm text-gray-400 mb-3">Select one or more:</p>
        <div class="grid sm:grid-cols-3 gap-3">
          <!-- Basic gojūon -->
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="vowels" checked />
            <span>Vowels (a, i, u, e, o)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="k" checked />
            <span>K row (ka, ki, ku, ke, ko)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="s" checked />
            <span>S row (sa, shi, su, se, so)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="t" checked />
            <span>T row (ta, chi, tsu, te, to)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="n" checked />
            <span>N row (na, ni, nu, ne, no)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="h" checked />
            <span>H row (ha, hi, fu, he, ho)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="m" checked />
            <span>M row (ma, mi, mu, me, mo)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="y" checked />
            <span>Y row (ya, yu, yo)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="r" checked />
            <span>R row (ra, ri, ru, re, ro)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="w" checked />
            <span>W row (wa, wo)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="special" checked />
            <span>Special (n)</span>
          </label>

          <!-- Dakuten / handakuten -->
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="g" checked />
            <span>G row (ga, gi, gu, ge, go)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="z" checked />
            <span>Z row (za, ji, zu, ze, zo)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="d" checked />
            <span>D row (da, ji, zu, de, do)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="b" checked />
            <span>B row (ba, bi, bu, be, bo)</span>
          </label>
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="p" checked />
            <span>P row (pa, pi, pu, pe, po)</span>
          </label>

          <!-- Yōon (aggregate) -->
          <label class="flex items-center gap-2 border border-gray-700 rounded-xl p-3 cursor-pointer">
            <input type="checkbox" class="charPool w-4 h-4" value="yoon" checked />
            <span>Yōon (kya, sha, cha, nya, etc.)</span>
          </label>
        </div>


        <!-- Presets -->
        <h3 class="text-sm font-semibold mb-2 text-gray-300">Presets</h3>
        <p class="text-xs text-gray-500 mt-2">
          Presets adjust the checkbox selection above. You can tweak further after applying.
        </p>
        <!-- Buttons grid -->

        <div class="grid grid-cols-2 sm:grid-cols-4 gap-2">
          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5" data-preset="kst">K/S/T rows</button>
          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5" data-preset="vowelsY">Vowels +
            Y</button>
          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5" data-preset="starters">Starters
            (Vowels
            + K + S)</button>
          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5" data-preset="basics">Basics</button>

          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5" data-preset="dakuten">Dakuten</button>
          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5"
            data-preset="handakuten">Handakuten</button>

          <!-- Force this one to the start of row 3 at sm+ -->
          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5 sm:col-start-1 sm:row-start-3"
            data-preset="all">All Kana</button>

          <button type="button" class="btn btn-secondary text-sm px-3 py-1.5 sm:col-start-2 sm:row-start-3"
            data-preset="clear">Clear all</button>
        </div>

      </div>




      <!-- Repetitions + Question Count -->
      <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
        <h2 class="text-xl font-semibold mb-3">Repetitions</h2>
        <div class="flex items-center gap-3">
          <input type="number" id="repetitions" min="1" value="1"
            class="w-28 p-2 border border-gray-700 rounded bg-gray-900 text-gray-100" />
          <span class="text-sm text-gray-400">Each picked character may appears this number of times.</span>
        </div>

        <div class="mt-4">
          <h3 class="text-base font-semibold mb-2">Questions</h3>
          <div class="flex items-center gap-3">
            <input type="number" id="questionCount" min="0" value="0"
              class="w-28 p-2 border border-gray-700 rounded bg-gray-900 text-gray-100" />
            <span class="text-sm text-gray-400">How many questions to ask (max <span id="maxQuestions">0</span>).</span>
          </div>
        </div>
      </div>

      <div class="flex items-center justify-between gap-3">
        <button id="openReference" class="btn btn-secondary">Kana Chart</button>
        <button id="startQuiz" class="btn btn-primary">Start Quiz</button>
      </div>
    </section>

    <!-- Quiz Screen -->
    <section id="quizScreen" class="hidden">
      <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
        <div class="flex items-center justify-between">
          <button class="btn btn-ghost js-back-menu">Back to Menu</button>
          <div class="text-sm text-gray-400">Score: <span id="scoreNow">0</span></div>
        </div>

        <div class="mt-4">

          <!-- Prompt + feedback (centered, with spacing) -->
          <div class="mb-4">
            <div id="questionPrompt" class="text-3xl font-semibold text-center transition-opacity duration-500">—</div>
            <div id="feedback" role="status" aria-live="polite"
              class="mt-2 h-7 text-2xl text-center transition-opacity duration-500"></div>
          </div>

          <!-- Hint under prompt -->
          <div id="promptHint" class="text-xs text-gray-500 text-center"></div>

          <!-- Typing -->
          <div id="textAnswerWrap" class="mt-3 mb-4 hidden transition-opacity duration-500">
            <input id="textAnswer" type="text" placeholder="Type your answer and press Enter"
              class="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 focus:outline-none">
            <p class="text-xs text-gray-500">For Romaji: type either IME <code>kbd</code> (e.g., <code>si</code>) or
              phonetic <code>phon</code> (e.g., <code>shi</code>).</p>
          </div>

          <!-- Multiple choice -->
          <div id="mcWrap" class="mt-3 grid sm:grid-cols-2 gap-2 mb-4 hidden transition-opacity duration-500"></div>

          <!-- Drawing -->
          <div id="drawWrap" class="mt-3 hidden mb-4 transition-opacity duration-500">
            <canvas id="drawCanvas" class="w-full bg-gray-900 rounded border border-gray-700" height="220"></canvas>
            <div class="flex gap-2">
              <button id="clearCanvas" class="btn btn-secondary">Clear</button>
              <button id="revealCorrect" class="btn btn-secondary">Reveal Answer</button>
            </div>
            <div id="revealArea" class="hidden text-2xl"><span id="correctGlyph"></span></div>
            <div class="flex gap-2">
              <button id="selfMarkRight" class="btn btn-primary">I got it</button>
              <button id="selfMarkWrong" class="btn btn-secondary">I missed</button>
            </div>
          </div>
        </div>

        <div class="flex items-center justify-between mt-3">
          <div class="text-sm text-gray-400">Question <span id="qIndex">0</span>/<span id="qTotal">0</span></div>
          <button id="nextQ" class="btn btn-ghost">Next</button>
        </div>
      </div>

      <!-- Recent answers -->
      <div id="recentPanel" class="mt-4">
        <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
          <div class="flex items-center justify-between mb-2">
            <h3 class="text-lg font-semibold">Recent Answers</h3>
            <span class="text-xs text-gray-500">Last 5</span>
          </div>
          <ol id="recentList" class="space-y-2 min-h-[2.5rem]" aria-live="polite" aria-label="Recent answers">
            <!-- items injected -->
          </ol>
        </div>
      </div>
    </section>

    <!-- Score Screen -->
    <section id="scoreScreen" class="hidden">
      <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
        <h2 class="text-2xl font-bold mb-2">Your Score</h2>
        <p id="scoreSummary" class="text-lg mb-4"></p>
        <div id="wrongAnswers" class="space-y-2 mb-6"></div>
        <div class="flex justify-end">
          <button class="btn btn-ghost js-back-menu">Back to Menu</button>
        </div>
      </div>
    </section>
  </div>
  <div class="max-w-5xl mx-auto p-6">
    <!-- Reference Screen -->
    <section id="referenceScreen" class="hidden">
      <div class="bg-gray-800 shadow-sm rounded-2xl p-5">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-2xl font-bold">Kana Chart</h2>
          <button class="btn btn-ghost js-back-menu">Back to Menu</button>
        </div>
        <p class="text-sm text-gray-400 mb-3">
          Gojūon including dakuten (゛), handakuten (゜) and yōon (ゃ/ゅ/ょ). Each vowel column shows <span
            class="font-semibold">Kana</span>, <span class="font-semibold">kbd</span> (IME entry), and <span
            class="font-semibold">phon</span> (pronunciation; only shown if different from <em>kbd</em>).
        </p>
        <div id="kanaTable" class="overflow-x-auto"></div>

        <div class="mt-4">
          <div class="inline-flex items-center gap-2 border border-gray-700 rounded-xl px-3 py-2">
            <span class="text-sm text-gray-300">Special:</span>
            <span class="text-xl">ん</span>
            <span class="text-xl">/</span>
            <span class="text-xl">ン</span>
          </div>
        </div>
      </div>
    </section>
  </div>


  <script>
    // ===== Data =====
    const KANA = [
      // Vowels
      { r: 'a', kbd: 'a', kbdAlt: [], h: 'あ', k: 'ア', cat: 'vowels' },
      { r: 'i', kbd: 'i', kbdAlt: [], h: 'い', k: 'イ', cat: 'vowels' },
      { r: 'u', kbd: 'u', kbdAlt: [], h: 'う', k: 'ウ', cat: 'vowels' },
      { r: 'e', kbd: 'e', kbdAlt: [], h: 'え', k: 'エ', cat: 'vowels' },
      { r: 'o', kbd: 'o', kbdAlt: [], h: 'お', k: 'オ', cat: 'vowels' },

      // K
      { r: 'ka', kbd: 'ka', kbdAlt: [], h: 'か', k: 'カ', cat: 'k' },
      { r: 'ki', kbd: 'ki', kbdAlt: [], h: 'き', k: 'キ', cat: 'k' },
      { r: 'ku', kbd: 'ku', kbdAlt: [], h: 'く', k: 'ク', cat: 'k' },
      { r: 'ke', kbd: 'ke', kbdAlt: [], h: 'け', k: 'ケ', cat: 'k' },
      { r: 'ko', kbd: 'ko', kbdAlt: [], h: 'こ', k: 'コ', cat: 'k' },

      // S
      { r: 'sa', kbd: 'sa', kbdAlt: [], h: 'さ', k: 'サ', cat: 's' },
      { r: 'shi', kbd: 'si', kbdAlt: ['shi'], h: 'し', k: 'シ', cat: 's' },
      { r: 'su', kbd: 'su', kbdAlt: [], h: 'す', k: 'ス', cat: 's' },
      { r: 'se', kbd: 'se', kbdAlt: [], h: 'せ', k: 'セ', cat: 's' },
      { r: 'so', kbd: 'so', kbdAlt: [], h: 'そ', k: 'ソ', cat: 's' },

      // T
      { r: 'ta', kbd: 'ta', kbdAlt: [], h: 'た', k: 'タ', cat: 't' },
      { r: 'chi', kbd: 'ti', kbdAlt: ['chi'], h: 'ち', k: 'チ', cat: 't' },
      { r: 'tsu', kbd: 'tu', kbdAlt: ['tsu'], h: 'つ', k: 'ツ', cat: 't' },
      { r: 'te', kbd: 'te', kbdAlt: [], h: 'て', k: 'テ', cat: 't' },
      { r: 'to', kbd: 'to', kbdAlt: [], h: 'と', k: 'ト', cat: 't' },

      // N
      { r: 'na', kbd: 'na', kbdAlt: [], h: 'な', k: 'ナ', cat: 'n' },
      { r: 'ni', kbd: 'ni', kbdAlt: [], h: 'に', k: 'ニ', cat: 'n' },
      { r: 'nu', kbd: 'nu', kbdAlt: [], h: 'ぬ', k: 'ヌ', cat: 'n' },
      { r: 'ne', kbd: 'ne', kbdAlt: [], h: 'ね', k: 'ネ', cat: 'n' },
      { r: 'no', kbd: 'no', kbdAlt: [], h: 'の', k: 'ノ', cat: 'n' },

      // H
      { r: 'ha', kbd: 'ha', kbdAlt: [], h: 'は', k: 'ハ', cat: 'h' },
      { r: 'hi', kbd: 'hi', kbdAlt: [], h: 'ひ', k: 'ヒ', cat: 'h' },
      { r: 'fu', kbd: 'hu', kbdAlt: ['fu'], h: 'ふ', k: 'フ', cat: 'h' },
      { r: 'he', kbd: 'he', kbdAlt: [], h: 'へ', k: 'ヘ', cat: 'h' },
      { r: 'ho', kbd: 'ho', kbdAlt: [], h: 'ほ', k: 'ホ', cat: 'h' },

      // M
      { r: 'ma', kbd: 'ma', kbdAlt: [], h: 'ま', k: 'マ', cat: 'm' },
      { r: 'mi', kbd: 'mi', kbdAlt: [], h: 'み', k: 'ミ', cat: 'm' },
      { r: 'mu', kbd: 'mu', kbdAlt: [], h: 'む', k: 'ム', cat: 'm' },
      { r: 'me', kbd: 'me', kbdAlt: [], h: 'め', k: 'メ', cat: 'm' },
      { r: 'mo', kbd: 'mo', kbdAlt: [], h: 'も', k: 'モ', cat: 'm' },

      // Y
      { r: 'ya', kbd: 'ya', kbdAlt: [], h: 'や', k: 'ヤ', cat: 'y' },
      { r: 'yu', kbd: 'yu', kbdAlt: [], h: 'ゆ', k: 'ユ', cat: 'y' },
      { r: 'yo', kbd: 'yo', kbdAlt: [], h: 'よ', k: 'ヨ', cat: 'y' },

      // R
      { r: 'ra', kbd: 'ra', kbdAlt: [], h: 'ら', k: 'ラ', cat: 'r' },
      { r: 'ri', kbd: 'ri', kbdAlt: [], h: 'り', k: 'リ', cat: 'r' },
      { r: 'ru', kbd: 'ru', kbdAlt: [], h: 'る', k: 'ル', cat: 'r' },
      { r: 're', kbd: 're', kbdAlt: [], h: 'れ', k: 'レ', cat: 'r' },
      { r: 'ro', kbd: 'ro', kbdAlt: [], h: 'ろ', k: 'ロ', cat: 'r' },

      // W
      { r: 'wa', kbd: 'wa', kbdAlt: [], h: 'わ', k: 'ワ', cat: 'w' },
      { r: 'wo', kbd: 'wo', kbdAlt: ['o'], h: 'を', k: 'ヲ', cat: 'w' },

      // Dakuten: G
      { r: 'ga', kbd: 'ga', kbdAlt: [], h: 'が', k: 'ガ', cat: 'g' },
      { r: 'gi', kbd: 'gi', kbdAlt: [], h: 'ぎ', k: 'ギ', cat: 'g' },
      { r: 'gu', kbd: 'gu', kbdAlt: [], h: 'ぐ', k: 'グ', cat: 'g' },
      { r: 'ge', kbd: 'ge', kbdAlt: [], h: 'げ', k: 'ゲ', cat: 'g' },
      { r: 'go', kbd: 'go', kbdAlt: [], h: 'ご', k: 'ゴ', cat: 'g' },

      // Dakuten: Z
      { r: 'za', kbd: 'za', kbdAlt: [], h: 'ざ', k: 'ザ', cat: 'z' },
      { r: 'ji', kbd: 'zi', kbdAlt: ['ji'], h: 'じ', k: 'ジ', cat: 'z' },
      { r: 'zu', kbd: 'zu', kbdAlt: [], h: 'ず', k: 'ズ', cat: 'z' },
      { r: 'ze', kbd: 'ze', kbdAlt: [], h: 'ぜ', k: 'ゼ', cat: 'z' },
      { r: 'zo', kbd: 'zo', kbdAlt: [], h: 'ぞ', k: 'ゾ', cat: 'z' },

      // Dakuten: D
      { r: 'da', kbd: 'da', kbdAlt: [], h: 'だ', k: 'ダ', cat: 'd' },
      { r: 'ji', kbd: 'di', kbdAlt: ['ji'], h: 'ぢ', k: 'ヂ', cat: 'd' },
      { r: 'zu', kbd: 'du', kbdAlt: ['dzu'], h: 'づ', k: 'ヅ', cat: 'd' },
      { r: 'de', kbd: 'de', kbdAlt: [], h: 'で', k: 'デ', cat: 'd' },
      { r: 'do', kbd: 'do', kbdAlt: [], h: 'ど', k: 'ド', cat: 'd' },

      // Dakuten: B
      { r: 'ba', kbd: 'ba', kbdAlt: [], h: 'ば', k: 'バ', cat: 'b' },
      { r: 'bi', kbd: 'bi', kbdAlt: [], h: 'び', k: 'ビ', cat: 'b' },
      { r: 'bu', kbd: 'bu', kbdAlt: [], h: 'ぶ', k: 'ブ', cat: 'b' },
      { r: 'be', kbd: 'be', kbdAlt: [], h: 'べ', k: 'ベ', cat: 'b' },
      { r: 'bo', kbd: 'bo', kbdAlt: [], h: 'ぼ', k: 'ボ', cat: 'b' },

      // Handakuten: P
      { r: 'pa', kbd: 'pa', kbdAlt: [], h: 'ぱ', k: 'パ', cat: 'p' },
      { r: 'pi', kbd: 'pi', kbdAlt: [], h: 'ぴ', k: 'ピ', cat: 'p' },
      { r: 'pu', kbd: 'pu', kbdAlt: [], h: 'ぷ', k: 'プ', cat: 'p' },
      { r: 'pe', kbd: 'pe', kbdAlt: [], h: 'ぺ', k: 'ペ', cat: 'p' },
      { r: 'po', kbd: 'po', kbdAlt: [], h: 'ぽ', k: 'ポ', cat: 'p' },

      // Special
      { r: 'n', kbd: 'n', kbdAlt: ["nn", "n'"], h: 'ん', k: 'ン', cat: 'special' },
    ];

    // Append YŌON
    KANA.push(
      // KY
      { r: 'kya', kbd: 'kya', kbdAlt: [], h: 'きゃ', k: 'キャ', cat: 'ky' },
      { r: 'kyu', kbd: 'kyu', kbdAlt: [], h: 'きゅ', k: 'キュ', cat: 'ky' },
      { r: 'kyo', kbd: 'kyo', kbdAlt: [], h: 'きょ', k: 'キョ', cat: 'ky' },

      // GY
      { r: 'gya', kbd: 'gya', kbdAlt: [], h: 'ぎゃ', k: 'ギャ', cat: 'gy' },
      { r: 'gyu', kbd: 'gyu', kbdAlt: [], h: 'ぎゅ', k: 'ギュ', cat: 'gy' },
      { r: 'gyo', kbd: 'gyo', kbdAlt: [], h: 'ぎょ', k: 'ギョ', cat: 'gy' },

      // SH
      { r: 'sha', kbd: 'sya', kbdAlt: ['sha'], h: 'しゃ', k: 'シャ', cat: 'sh' },
      { r: 'shu', kbd: 'syu', kbdAlt: ['shu'], h: 'しゅ', k: 'シュ', cat: 'sh' },
      { r: 'sho', kbd: 'syo', kbdAlt: ['sho'], h: 'しょ', k: 'ショ', cat: 'sh' },

      // CH
      { r: 'cha', kbd: 'tya', kbdAlt: ['cha', 'cya'], h: 'ちゃ', k: 'チャ', cat: 'ch' },
      { r: 'chu', kbd: 'tyu', kbdAlt: ['chu', 'cyu'], h: 'ちゅ', k: 'チュ', cat: 'ch' },
      { r: 'cho', kbd: 'tyo', kbdAlt: ['cho', 'cyo'], h: 'ちょ', k: 'チョ', cat: 'ch' },

      // J
      { r: 'ja', kbd: 'zya', kbdAlt: ['ja', 'jya'], h: 'じゃ', k: 'ジャ', cat: 'j' },
      { r: 'ju', kbd: 'zyu', kbdAlt: ['ju', 'jyu'], h: 'じゅ', k: 'ジュ', cat: 'j' },
      { r: 'jo', kbd: 'zyo', kbdAlt: ['jo', 'jyo'], h: 'じょ', k: 'ジョ', cat: 'j' },

      // DY (rare)
      { r: 'ja', kbd: 'dya', kbdAlt: ['ja', 'jya'], h: 'ぢゃ', k: 'ヂャ', cat: 'dy' },
      { r: 'ju', kbd: 'dyu', kbdAlt: ['ju', 'jyu'], h: 'ぢゅ', k: 'ヂュ', cat: 'dy' },
      { r: 'jo', kbd: 'dyo', kbdAlt: ['jo', 'jyo'], h: 'ぢょ', k: 'ヂョ', cat: 'dy' },

      // NY
      { r: 'nya', kbd: 'nya', kbdAlt: [], h: 'にゃ', k: 'ニャ', cat: 'ny' },
      { r: 'nyu', kbd: 'nyu', kbdAlt: [], h: 'にゅ', k: 'ニュ', cat: 'ny' },
      { r: 'nyo', kbd: 'nyo', kbdAlt: [], h: 'にょ', k: 'ニョ', cat: 'ny' },

      // HY
      { r: 'hya', kbd: 'hya', kbdAlt: [], h: 'ひゃ', k: 'ヒャ', cat: 'hy' },
      { r: 'hyu', kbd: 'hyu', kbdAlt: [], h: 'ひゅ', k: 'ヒュ', cat: 'hy' },
      { r: 'hyo', kbd: 'hyo', kbdAlt: [], h: 'ひょ', k: 'ヒョ', cat: 'hy' },

      // BY
      { r: 'bya', kbd: 'bya', kbdAlt: [], h: 'びゃ', k: 'ビャ', cat: 'by' },
      { r: 'byu', kbd: 'byu', kbdAlt: [], h: 'びゅ', k: 'ビュ', cat: 'by' },
      { r: 'byo', kbd: 'byo', kbdAlt: [], h: 'びょ', k: 'ビョ', cat: 'by' },

      // PY
      { r: 'pya', kbd: 'pya', kbdAlt: [], h: 'ぴゃ', k: 'ピャ', cat: 'py' },
      { r: 'pyu', kbd: 'pyu', kbdAlt: [], h: 'ぴゅ', k: 'ピュ', cat: 'py' },
      { r: 'pyo', kbd: 'pyo', kbdAlt: [], h: 'ぴょ', k: 'ピョ', cat: 'py' },

      // MY
      { r: 'mya', kbd: 'mya', kbdAlt: [], h: 'みゃ', k: 'ミャ', cat: 'my' },
      { r: 'myu', kbd: 'myu', kbdAlt: [], h: 'みゅ', k: 'ミュ', cat: 'my' },
      { r: 'myo', kbd: 'myo', kbdAlt: [], h: 'みょ', k: 'ミョ', cat: 'my' },

      // RY
      { r: 'rya', kbd: 'rya', kbdAlt: [], h: 'りゃ', k: 'リャ', cat: 'ry' },
      { r: 'ryu', kbd: 'ryu', kbdAlt: [], h: 'りゅ', k: 'リュ', cat: 'ry' },
      { r: 'ryo', kbd: 'ryo', kbdAlt: [], h: 'りょ', k: 'リョ', cat: 'ry' },
    );

    const YOON_CATS = new Set(['ky', 'gy', 'sh', 'j', 'ch', 'ny', 'hy', 'by', 'py', 'my', 'ry', 'dy']);

    // ===== Helpers =====
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function sample(arr, n) {
      const copy = arr.slice();
      shuffle(copy);
      return copy.slice(0, n);
    }
    let mcKeyHandler = null;

    function escapeHtml(s) {
      return String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
    // ===== Build sets, presets, meta =====
    function buildBaseSet(poolCats) {
      const chosen = new Set(poolCats);
      return KANA.filter(k =>
        chosen.has(k.cat) ||
        (chosen.has('yoon') && YOON_CATS.has(k.cat))
      );
    }

    function expandWithRepetitions(arr, reps) {
      const out = [];
      for (let i = 0; i < reps; i++) out.push(...arr.map(x => ({ ...x })));
      return out;
    }

    function selectedQuizMeta(quizType) {
      switch (quizType) {
        case 'kataToRoma': return { from: 'katakana', to: 'romaji' };
        case 'hiraToRoma': return { from: 'hiragana', to: 'romaji' };
        case 'mixedToRoma': return { from: 'mixedKana', to: 'romaji' };
        case 'hiraToKata': return { from: 'hiragana', to: 'katakana' };
        case 'kataToHira': return { from: 'katakana', to: 'hiragana' };
        case 'romaToHira': return { from: 'romaji', to: 'hiragana' };
        case 'romaToKata': return { from: 'romaji', to: 'katakana' };
        default: return { from: 'katakana', to: 'romaji' };
      }
    }

    function createQuestions(quizType, poolCats, repetitions, answerMode) {
      const meta = selectedQuizMeta(quizType);
      const base = buildBaseSet(poolCats);

      let units = [];

      if (meta.from === 'mixedKana') {
        base.forEach(item => {
          units.push({
            prompt: item.h,
            correct: meta.to === 'romaji' ? item.r : meta.to === 'hiragana' ? item.h : item.k,
            acceptable: meta.to === 'romaji' ? new Set([item.r, item.kbd, ...(item.kbdAlt || [])].map(s => s.toLowerCase())) : null
          });
          units.push({
            prompt: item.k,
            correct: meta.to === 'romaji' ? item.r : meta.to === 'hiragana' ? item.h : item.k,
            acceptable: meta.to === 'romaji' ? new Set([item.r, item.kbd, ...(item.kbdAlt || [])].map(s => s.toLowerCase())) : null
          });
        });
      } else {
        base.forEach(item => {
          const prompt =
            meta.from === 'katakana' ? item.k :
              meta.from === 'hiragana' ? item.h :
                item.r;

          const correct =
            meta.to === 'romaji' ? item.r :
              meta.to === 'hiragana' ? item.h :
                item.k;

          const acceptable = (meta.to === 'romaji')
            ? new Set([item.r, item.kbd, ...(item.kbdAlt || [])].map(s => s.toLowerCase()))
            : null;

          units.push({ prompt, correct, acceptable });
        });
      }

      const sourceExpanded = expandWithRepetitions(units, repetitions);
      const kind = (answerMode === 'mc') ? 'mc' : (answerMode === 'draw' && (selectedQuizMeta(quizType).to !== 'romaji')) ? 'draw' : 'text';

      const q = shuffle(sourceExpanded).map(u => {
        let hint = '';
        if (kind === 'text' && meta.to === 'romaji') hint = 'Type romaji (IME kbd or phonetic)';
        else if (kind === 'mc') hint = `Pick the correct ${meta.to}`;
        else if (kind === 'draw') hint = `Draw the ${meta.to}`;

        return { kind, prompt: u.prompt, correct: u.correct, acceptable: u.acceptable, meta };
      });
      return q;
    }

    // ===== UI =====
    const state = {
      questions: [],
      index: 0,
      score: 0,
      wrong: [],
      poolCats: ['vowels', 'k', 's', 't', 'n', 'h', 'm', 'y', 'r', 'w', 'special', 'g', 'z', 'd', 'b', 'p', 'yoon'],
    };



    const questionPromptEl = document.getElementById('questionPrompt');
    const feedbackEl = document.getElementById('feedback');
    const FEEDBACK_BASE = 'h-7 text-2xl text-center transition-opacity duration-500';
    const promptHint = document.getElementById('promptHint');
    const textAnswerWrap = document.getElementById('textAnswerWrap');
    const textAnswer = document.getElementById('textAnswer');
    const mcWrap = document.getElementById('mcWrap');
    const drawWrap = document.getElementById('drawWrap');
    const drawCanvas = document.getElementById('drawCanvas');
    const clearCanvasBtn = document.getElementById('clearCanvas');
    const revealBtn = document.getElementById('revealCorrect');
    const revealArea = document.getElementById('revealArea');
    const correctGlyph = document.getElementById('correctGlyph');

    const repsEl = document.getElementById('repetitions');
    const qCountEl = document.getElementById('questionCount');
    const maxQEl = document.getElementById('maxQuestions');
    const startQuizBtn = document.getElementById('startQuiz');

    const scoreNow = document.getElementById('scoreNow');
    const scoreSummary = document.getElementById('scoreSummary');
    const wrongAnswers = document.getElementById('wrongAnswers');
    const qIndex = document.getElementById('qIndex');
    const qTotal = document.getElementById('qTotal');

    const modeText = document.getElementById('answerModeText');
    const bigModeMCLabel = document.getElementById('modeMCLabel');
    const modeMC = document.getElementById('answerModeMC');
    const modeDraw = document.getElementById('answerModeDraw');

    const distractorRow = document.getElementById('distractorRow');
    const distractorSelectedOnly = document.getElementById('distractorSelectedOnly');

    const FADE_TARGETS = [questionPromptEl, feedbackEl, promptHint, textAnswerWrap, mcWrap, drawWrap];
    let isFading = false;
    const FADE_MS = 550;

    const recentList = document.getElementById('recentList');
    const RECENT_MAX = 5;
    const RECENT_FADE_MS = 550;

    // ===== SFX (Web Audio, no assets) =====
    let audioCtx = null;
    let sfxGain = null; // master volume

    function ensureAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC();
        sfxGain = audioCtx.createGain();
        sfxGain.gain.value = 0.22; // tweak volume 0.0–1.0
        sfxGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function tone({ freq = 440, type = 'sine', start = 0, duration = 0.15, gain = 0.22 }) {
      ensureAudio();
      const t0 = audioCtx.currentTime + start;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      osc.type = type;
      osc.frequency.value = freq;

      // Simple ADSR-ish envelope
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);

      osc.connect(g);
      g.connect(sfxGain);

      osc.start(t0);
      osc.stop(t0 + duration + 0.02);
    }

    function playCorrect() {
      // Upward two-note chime (E5 → A5)
      tone({ freq: 659.25, type: 'triangle', duration: 0.12, gain: 0.24 });
      tone({ freq: 880.00, type: 'triangle', start: 0.10, duration: 0.18, gain: 0.24 });
    }

    function playWrong() {
      ensureAudio();
      const t = audioCtx.currentTime;

      // Base buzz
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      osc.type = 'square';
      osc.frequency.setValueAtTime(220, t);
      osc.frequency.exponentialRampToValueAtTime(140, t + 0.25);

      // Quick attack/decay
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.22, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.28);

      // Add a little FM “rasp” with an LFO
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 20;      // 20 Hz wobble
      lfoGain.gain.value = 40;       // depth in Hz
      lfo.connect(lfoGain);
      lfoGain.connect(osc.frequency);

      osc.connect(g);
      g.connect(sfxGain);

      osc.start(t);
      lfo.start(t);
      lfo.stop(t + 0.3);
      osc.stop(t + 0.3);
    }

    function playFanfare() {
      // Bright opening chord (C5–E5–G5)
      tone({ freq: 523.25, type: 'sawtooth', start: 0.00, duration: 0.18, gain: 0.26 }); // C5
      tone({ freq: 659.25, type: 'sawtooth', start: 0.00, duration: 0.18, gain: 0.24 }); // E5
      tone({ freq: 783.99, type: 'sawtooth', start: 0.00, duration: 0.18, gain: 0.22 }); // G5

      // A little low "ta-da" body
      tone({ freq: 196.00, type: 'square', start: 0.02, duration: 0.14, gain: 0.14 }); // G3
      tone({ freq: 261.63, type: 'square', start: 0.02, duration: 0.14, gain: 0.12 }); // C4

      // Quick ascending run (G5 → A5 → B5 → C6)
      const step = 0.16;
      tone({ freq: 783.99, type: 'triangle', start: 0.20, duration: 0.12, gain: 0.22 }); // G5
      tone({ freq: 880.00, type: 'triangle', start: 0.20 + 1 * step, duration: 0.12, gain: 0.22 }); // A5
      tone({ freq: 987.77, type: 'triangle', start: 0.20 + 2 * step, duration: 0.12, gain: 0.22 }); // B5
      tone({ freq: 1046.50, type: 'triangle', start: 0.20 + 3 * step, duration: 0.18, gain: 0.24 }); // C6

      // Sparkly capstone chord (C6–E6–G6)
      const cap = 0.20 + 3 * step + 0.06;
      tone({ freq: 1046.50, type: 'triangle', start: cap, duration: 0.18, gain: 0.24 }); // C6
      tone({ freq: 1318.51, type: 'triangle', start: cap, duration: 0.18, gain: 0.18 }); // E6
      tone({ freq: 1567.98, type: 'triangle', start: cap, duration: 0.18, gain: 0.14 }); // G6
    }


    function clearRecent() {
      if (recentList) recentList.innerHTML = '';
    }

    function showScreen(targetId) {
      ['mainMenu', 'quizScreen', 'scoreScreen', 'referenceScreen'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        if (id === targetId) el.classList.remove('hidden');
        else el.classList.add('hidden');
      });
    }

    function fadeRemoveAsync(el, duration = RECENT_FADE_MS) {
      return new Promise((resolve) => {
        if (!el) return resolve();
        el.style.transitionProperty = 'opacity';
        el.style.transitionDuration = `${duration}ms`;
        el.classList.remove('opacity-100');
        el.classList.add('opacity-0');
        const cleanup = () => {
          if (el && el.parentNode) el.parentNode.removeChild(el);
          resolve();
        };
        el.addEventListener('transitionend', cleanup, { once: true });
        setTimeout(cleanup, duration + 50);
      });
    }

    function recordRecent({ ok, prompt, user, correct }) {
      if (!recentList) return;

      // Build item (starts invisible)
      const li = document.createElement('li');
      li.className = 'px-3 py-2 rounded-lg border border-gray-700 bg-gray-900/40 ' +
        'transition-opacity duration-300 opacity-0';
      li.style.transitionProperty = 'opacity';
      li.style.transitionDuration = `${RECENT_FADE_MS}ms`;
      li.innerHTML = `
    <div class="flex items-center justify-between">
      <div class="text-xl mr-3">${escapeHtml(prompt)}</div>
      <div class="${ok ? 'text-green-400' : 'text-red-400'} text-xl">${ok ? '✅' : '❌'}</div>
    </div>
    <div class="mt-1 text-xs text-gray-400"><span class="text-gray-500">You:</span> ${escapeHtml(user || '—')}</div>
    <div class="text-xs text-gray-400"><span class="text-gray-500">Correct:</span> ${escapeHtml(correct || '—')}</div>
  `;
      const fadeInNew = () => {
        recentList.prepend(li);
        requestAnimationFrame(() => {
          li.classList.remove('opacity-0');
          li.classList.add('opacity-100');
        });
      };

      // If the list is already full, fade out overflow first, then fade-in the new item
      // (Keep at most RECENT_MAX-1 existing items before inserting the new one.)
      const overflow = Array.from(recentList.children).slice(RECENT_MAX - 1);
      if (overflow.length) {
        Promise.all(overflow.map(node => fadeRemoveAsync(node, RECENT_FADE_MS)))
          .then(fadeInNew);
      } else {
        fadeInNew();
      }
    }

    // Answer mode availability
    function updateAnswerModeAvailability() {
      const quizType = (document.querySelector('input[name="quizType"]:checked') || {}).value || 'mixedToRoma';
      const meta = selectedQuizMeta(quizType);
      // Typing always available
      modeText.disabled = false;
      document.getElementById('modeTextLabel').classList.toggle('opacity-50', false);
      // MC always available
      modeMC.disabled = false;
      document.getElementById('modeMCLabel').classList.toggle('opacity-50', false);
      // Draw only when answering to kana
      const drawOK = (meta.to === 'hiragana' || meta.to === 'katakana');
      modeDraw.disabled = !drawOK;
      document.getElementById('modeDrawLabel').classList.toggle('opacity-50', !drawOK);
      distractorRow.classList.toggle('hidden', !(meta.to !== 'romaji' && modeMC.checked));
      document.getElementById('distractorLabel').classList.toggle('opacity-50', !(meta.to !== 'romaji' && modeMC.checked));

      // Recompute max questions when quiz type changes
      updateQuestionLimit(true);
    }

    $$('.grid input[name="quizType"]').forEach(r => r.addEventListener('change', updateAnswerModeAvailability));
    $$('input[name="answerMode"]').forEach(r => r.addEventListener('change', updateAnswerModeAvailability));
    updateAnswerModeAvailability();

    // Presets
    function setPools(values) {
      const boxes = $$('.charPool');
      const set = new Set(values);
      boxes.forEach(b => { b.checked = set.has(b.value); });
      state.poolCats = values.slice();
    }
    function applyPreset(key) {
      const ALL = ['vowels', 'k', 's', 't', 'n', 'h', 'm', 'y', 'r', 'w', 'special', 'g', 'z', 'd', 'b', 'p', 'yoon'];
      switch (key) {
        case 'kst': setPools(['k', 's', 't']); break;
        case 'vowelsY': setPools(['vowels', 'y']); break;
        case 'starters': setPools(['vowels', 'k', 's']); break;
        case 'basics': setPools(['vowels', 'k', 's', 't', 'n', 'h', 'm', 'y', 'r', 'w', 'special']); break;
        case 'dakuten': setPools(['g', 'z', 'd', 'b']); break;
        case 'handakuten': setPools(['p']); break;
        case 'all': setPools(ALL); break;
        case 'clear': setPools([]); break;
      }
      updateQuestionLimit(true);
    }
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-preset]');
      if (!btn) return;
      applyPreset(btn.getAttribute('data-preset'));
    });

    // Pool checkboxes
    $$('.charPool').forEach(cb => {
      cb.addEventListener('change', () => {
        if (cb.checked) {
          if (!state.poolCats.includes(cb.value)) state.poolCats.push(cb.value);
        } else {
          state.poolCats = state.poolCats.filter(v => v !== cb.value);
        }
        updateQuestionLimit(true);
      });
    });

    // ===== Question-limit logic =====
    function computePoolSize() {
      return buildBaseSet(state.poolCats.slice()).length;
    }
    function computeMaxQuestions() {
      const quizType = (document.querySelector('input[name="quizType"]:checked') || {}).value || 'kataToRoma';
      const reps = Math.max(1, parseInt(repsEl.value || '1', 10));
      const baseSize = computePoolSize();
      const factor = (selectedQuizMeta(quizType).from === 'mixedKana') ? 2 : 1;
      return baseSize * factor * reps;
    }
    function updateQuestionLimit(setValueToMax) {
      const max = computeMaxQuestions();
      maxQEl.textContent = max;
      qCountEl.max = String(max);
      if (setValueToMax) {
        qCountEl.value = String(max);
      } else {
        const cur = Math.max(0, parseInt(qCountEl.value || '0', 10));
        if (cur > max) qCountEl.value = String(max);
      }
      startQuizBtn.disabled = (max === 0);
      startQuizBtn.setAttribute('aria-disabled', String(max === 0));
    }

    // Reps and manual questionCount adjustments
    repsEl.addEventListener('input', () => updateQuestionLimit(true));
    qCountEl.addEventListener('input', () => updateQuestionLimit(false));

    // Start / Back / Reference
    document.getElementById('startQuiz').addEventListener('click', () => {
      const quizType = (document.querySelector('input[name="quizType"]:checked') || {}).value || 'kataToRoma';
      const answerMode = (document.querySelector('input[name="answerMode"]:checked') || {}).value || 'mc';
      const reps = Math.max(1, parseInt(repsEl.value || '1', 10));
      const desired = Math.max(0, parseInt(qCountEl.value || '0', 10));

      const poolList = state.poolCats.slice();
      const allQ = createQuestions(quizType, poolList, reps, answerMode);
      state.questions = (desired > 0) ? allQ.slice(0, Math.min(desired, allQ.length)) : allQ;
      state.index = 0;
      state.score = 0;
      state.wrong = [];
      clearRecent();


      qTotal.textContent = state.questions.length;
      scoreNow.textContent = 0;

      showScreen('quizScreen');
      showQuestion();
      fadeInQA();
    });

    $$('.js-back-menu').forEach(b => b.addEventListener('click', () => showScreen('mainMenu')));

    document.getElementById('openReference').addEventListener('click', () => {
      showScreen('referenceScreen');
      buildKanaTable();
    });

    // Render Question
    function showQuestion() {
      const q = state.questions[state.index];
      qIndex.textContent = state.index + 1;
      questionPromptEl.textContent = q.prompt;

      if (q.kind === 'text' && q.meta.to === 'romaji') {
        if (promptHint) promptHint.textContent = 'Type romaji (IME kbd or phonetic), Enter to submit';
      } else if (q.kind === 'mc') {
        if (promptHint) promptHint.textContent = `Pick the correct ${q.meta.to} (press 1–4)`;
      } else if (q.kind === 'draw') {
        if (promptHint) promptHint.textContent = `Draw the ${q.meta.to}`;
      } else {
        if (promptHint) promptHint.textContent = '';
      }

      textAnswerWrap.classList.toggle('hidden', q.kind !== 'text');
      mcWrap.innerHTML = '';
      mcWrap.classList.toggle('hidden', q.kind !== 'mc');
      drawWrap.classList.toggle('hidden', q.kind !== 'draw');

      if (q.kind === 'text') {
        textAnswer.value = '';
        textAnswer.focus();
      } else if (q.kind === 'mc') {
        renderMC(q);
      } else if (q.kind === 'draw') {
        initCanvas();
        revealArea.classList.add('hidden');
      }

      setFeedbackEmpty(); // reserve space, invisible
    }

    // Typing submit (accept kbd/phon variants)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !textAnswerWrap.classList.contains('hidden')) {
        const q = state.questions[state.index];
        const user = (textAnswer.value || '').trim().toLowerCase();
        const correct = (q.correct || '').toLowerCase();
        const ok = q.acceptable instanceof Set
          ? q.acceptable.has(user.toLowerCase())
          : user.toLowerCase() === correct.toLowerCase();
        recordRecent({ ok, prompt: q.prompt, user, correct })
        if (!ok) {
          state.wrong.push({ prompt: q.prompt, user, correct });
        } else {
          state.score++;
          scoreNow.textContent = state.score;
        }
        showFeedbackAndAdvance(ok);
      }
    });

    // Number key shortcuts for MC: 1–4
    document.addEventListener('keydown', (e) => {
      if (mcWrap.classList.contains('hidden') || isFading) return;
      const key = e.key;
      if (key === '1' || key === '2' || key === '3' || key === '4') {
        const idx = parseInt(key, 10) - 1;
        const btns = mcWrap.querySelectorAll('button');
        if (btns[idx]) {
          e.preventDefault();
          btns[idx].click();
        }
      }
    });

    // MC rendering (adds numeric labels 1) .. 4))
    function renderMC(q) {
      mcWrap.innerHTML = '';
      const pool = buildBaseSet(state.poolCats.slice());
      const distractors = shuffle(pool.filter(x => {
        const ans = q.correct;
        return (ans !== x.r && ans !== x.h && ans !== x.k);
      })).slice(0, 3);

      const options = [q.correct, ...distractors.map(d =>
        q.meta.to === 'romaji' ? d.r : (q.meta.to === 'hiragana' ? d.h : d.k)
      )];

      shuffle(options).forEach((opt, i) => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-secondary inline-flex items-center gap-2';
        btn.setAttribute('aria-label', `Option ${i + 1}: ${opt}`);

        // Keycap: small gray boxed number (looks like a keyboard key)
        const cap = document.createElement('span');
        cap.className = 'ml-1 mr-3 my-0.5 inline-flex items-center justify-center w-6 h-6 rounded-md border border-gray-600 bg-gray-200 font-mono text-xs text-slate-900 shadow-sm';
        cap.textContent = String(i + 1);

        const label = document.createElement('span');
        label.textContent = opt;

        // Build button content without disturbing your base .btn style
        btn.appendChild(cap);
        btn.appendChild(label);

        btn.addEventListener('click', () => {
          const ok = (opt.toString().toLowerCase() === q.correct.toString().toLowerCase());
          recordRecent({ ok, prompt: q.prompt, user: String(opt), correct: String(q.correct) });
          if (!ok) state.wrong.push({ prompt: q.prompt, user: opt, correct: q.correct });
          else { state.score++; scoreNow.textContent = state.score; }
          showFeedbackAndAdvance(ok);
        });

        mcWrap.appendChild(btn);
      });
    }


    // Drawing mode
    let ctx, drawing = false, last = null;
    function initCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const style = getComputedStyle(drawCanvas);
      const cssW = parseFloat(style.width);
      drawCanvas.width = Math.floor(cssW * ratio);
      drawCanvas.height = Math.floor(220 * ratio);

      ctx = drawCanvas.getContext('2d');
      ctx.scale(ratio, ratio);
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.strokeStyle = '#e5e7eb';

      drawCanvas.onpointerdown = (e) => { drawing = true; last = { x: e.offsetX, y: e.offsetY }; };
      drawCanvas.onpointermove = (e) => {
        if (!drawing) return;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(e.offsetX, e.offsetY);
        ctx.stroke();
        last = { x: e.offsetX, y: e.offsetY };
      };
      window.onpointerup = () => { drawing = false; };

      clearCanvasBtn.onclick = () => {
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      };
      revealBtn.onclick = () => {
        const q = state.questions[state.index];
        revealArea.classList.remove('hidden');
        correctGlyph.textContent = q.correct;
      };
      document.getElementById('selfMarkRight').onclick = () => {
        state.score++;
        scoreNow.textContent = state.score;
        recordRecent({ ok: true, prompt: q.prompt, user: '[draw]', correct: String(q.correct) });
        showFeedbackAndAdvance(true);
      };
      document.getElementById('selfMarkWrong').onclick = () => {
        const q = state.questions[state.index];
        state.wrong.push({ prompt: q.prompt, user: '[draw]', correct: q.correct });
        recordRecent({ ok: false, prompt: q.prompt, user: '[draw]', correct: String(q.correct) });
        showFeedbackAndAdvance(false);
      };
    }

    // Fade + feedback
    function fadeOutQA(cb) {
      isFading = true;
      FADE_TARGETS.forEach(el => { if (el && !el.classList.contains('hidden')) el.style.opacity = '0'; });
      setTimeout(cb, FADE_MS);
    }

    function fadeInQA() {
      FADE_TARGETS.forEach(el => { if (el && !el.classList.contains('hidden')) el.style.opacity = '0'; });
      requestAnimationFrame(() => {
        FADE_TARGETS.forEach(el => { if (el && !el.classList.contains('hidden')) el.style.opacity = '1'; });
      });
      setTimeout(() => { isFading = false; }, FADE_MS);
    }

    function setFeedbackEmpty() {
      if (!feedbackEl) return;
      feedbackEl.innerHTML = '&nbsp;';
      feedbackEl.className = `${FEEDBACK_BASE} opacity-0`;
      feedbackEl.setAttribute('aria-hidden', 'true');
    }

    function briefFeedback(ok) {
      if (!feedbackEl) return;
      feedbackEl.textContent = ok ? '✅' : '❌';
      feedbackEl.className = `${FEEDBACK_BASE} ${ok ? 'text-green-400' : 'text-red-400'} opacity-100`;
      feedbackEl.removeAttribute('aria-hidden');
    }

    function showFeedbackAndAdvance(ok) {
      if (feedbackEl) briefFeedback(ok);
      (ok ? playCorrect : playWrong)();
      setTimeout(() => {
        fadeOutQA(() => {
          setFeedbackEmpty();
          finishQuestionAndAdvance();
        });
      }, 300);
    }

    function finishQuestionAndAdvance() {
      state.index++;
      if (state.index >= state.questions.length) {
        showScreen('scoreScreen');
        scoreSummary.textContent = `Score: ${state.score}/${state.questions.length}`;
        if (state.wrong.length) {
          wrongAnswers.innerHTML = state.wrong.map(w =>
            `<div class="text-lg text-gray-300"><span class="text-gray-400">Prompt:</span> ${w.prompt} &nbsp; <span class="text-gray-400">Your answer:</span> ${w.user} &nbsp; <span class="text-gray-400">Correct:</span> ${w.correct}</div>`
          ).join('');
        } else {
          playFanfare();
          wrongAnswers.innerHTML = `<div class="text-lg text-center text-emerald-400">🎉 Flawless! 💯</div>`;
        }
        return;
      }
      showQuestion();
      fadeInQA();
    }

    document.getElementById('nextQ').addEventListener('click', () => {
      fadeOutQA(() => {
        setFeedbackEmpty();
        finishQuestionAndAdvance();
      });
    });

    // ===== Reference Table =====
    function buildKanaTable() {
      const byR = {};
      const byKey = {};
      for (const k of KANA) {
        if (!byR[k.r]) byR[k.r] = k;
        byKey[`${k.r}|${k.cat}`] = k;
      }

      const V = ['a', 'i', 'u', 'e', 'o'];
      const GOJUON = [
        { label: '—', seq: ['a', 'i', 'u', 'e', 'o'] },
        { label: 'K', seq: ['ka', 'ki', 'ku', 'ke', 'ko'] },
        { label: 'S', seq: ['sa', 'shi', 'su', 'se', 'so'] },
        { label: 'T', seq: ['ta', 'chi', 'tsu', 'te', 'to'] },
        { label: 'N', seq: ['na', 'ni', 'nu', 'ne', 'no'] },
        { label: 'H', seq: ['ha', 'hi', 'fu', 'he', 'ho'] },
        { label: 'M', seq: ['ma', 'mi', 'mu', 'me', 'mo'] },
        { label: 'Y', seq: ['ya', null, 'yu', null, 'yo'] },
        { label: 'R', seq: ['ra', 'ri', 'ru', 're', 'ro'] },
        { label: 'W', seq: ['wa', null, null, null, 'wo'] },
        { label: 'G', seq: ['ga', 'gi', 'gu', 'ge', 'go'] },
        { label: 'Z', seq: ['za', 'ji', 'zu', 'ze', 'zo'] },
        { label: 'D', seq: ['da', 'ji', 'zu', 'de', 'do'] },
        { label: 'B', seq: ['ba', 'bi', 'bu', 'be', 'bo'] },
        { label: 'P', seq: ['pa', 'pi', 'pu', 'pe', 'po'] },
      ];

      // Grouped header
      const mainHead = `
  <thead>
    <tr>
      <th class="px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 w-14" rowspan="2" scope="col">Row</th>
      ${V.map(v => `
        <th class="px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 uppercase text-center" colspan="3" scope="colgroup">${v}</th>
      `).join('')}
    </tr>
    <tr>
      ${V.map(() => `
        <th class="px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 text-center" scope="col">Kana</th>
        <th class="px-2 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 text-center whitespace-nowrap" scope="col">kbd&nbsp;</th>
        <th class="px-2 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 text-center whitespace-nowrap" scope="col">phon</th>
      `).join('')}
    </tr>
  </thead>`;

      let mainBody = '<tbody>';
      for (const row of GOJUON) {
        mainBody += `<tr class="hover:bg-gray-800/60">
          <th class="px-3 py-2 text-sm text-gray-300 border-t border-gray-700">${row.label}</th>`;
        for (let i = 0; i < V.length; i++) {
          const key = row.seq[i];
          if (!key || !byR[key]) {
            mainBody += `
              <td class="px-3 py-3 border-t border-gray-700 text-gray-600">—</td>
              <td class="px-2 py-3 border-t border-gray-700 text-center text-xs text-gray-500">—</td>
              <td class="px-2 py-3 border-t border-gray-700 text-center text-xs text-gray-500">—</td>`;
            continue;
          }
          const k = byR[key];
          mainBody += `
            <td class="px-3 py-3 border-t border-gray-700 align-middle">
              <div class="flex items-baseline gap-3">
                <div class="text-2xl">${k.h}</div>
                <div class="text-2xl">${k.k}</div>
              </div>
            </td>
            <td class="px-2 py-3 border-t border-gray-700 text-center text-xs"><code>${k.kbd}</code></td>
            <td class="px-2 py-3 border-t border-gray-700 text-center text-xs">${k.r !== k.kbd ? `<code>${k.r}</code>` : '—'}</td>`;
        }
        mainBody += `</tr>`;
      }
      mainBody += `</tbody>`;

      // Yōon
      const YV = ['ya', 'yu', 'yo'];
      const YOON_ROWS = [
        { label: 'KY', cat: 'ky', seq: ['kya', 'kyu', 'kyo'] },
        { label: 'GY', cat: 'gy', seq: ['gya', 'gyu', 'gyo'] },
        { label: 'SH', cat: 'sh', seq: ['sha', 'shu', 'sho'] },
        { label: 'CH', cat: 'ch', seq: ['cha', 'chu', 'cho'] },
        { label: 'J', cat: 'j', seq: ['ja', 'ju', 'jo'] },
        { label: 'DY', cat: 'dy', seq: ['ja', 'ju', 'jo'] },
        { label: 'NY', cat: 'ny', seq: ['nya', 'nyu', 'nyo'] },
        { label: 'HY', cat: 'hy', seq: ['hya', 'hyu', 'hyo'] },
        { label: 'BY', cat: 'by', seq: ['bya', 'byu', 'byo'] },
        { label: 'PY', cat: 'py', seq: ['pya', 'pyu', 'pyo'] },
        { label: 'MY', cat: 'my', seq: ['mya', 'myu', 'myo'] },
        { label: 'RY', cat: 'ry', seq: ['rya', 'ryu', 'ryo'] },
      ];

      const yHead = `
  <thead>
    <tr>
      <th class="px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 w-14" rowspan="2" scope="col">Yōon</th>
      ${YV.map(v => `
        <th class="px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 uppercase text-center" colspan="3" scope="colgroup">${v}</th>
      `).join('')}
    </tr>
    <tr>
      ${YV.map(() => `
        <th class="px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 text-center" scope="col">Kana</th>
        <th class="px-2 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 text-center whitespace-nowrap" scope="col">kbd&nbsp;</th>
        <th class="px-2 py-2 text-xs font-semibold text-gray-400 border-b border-gray-700 text-center whitespace-nowrap" scope="col">phon</th>
      `).join('')}
    </tr>
  </thead>`;

      let yBody = '<tbody>';
      for (const row of YOON_ROWS) {
        yBody += `<tr class="hover:bg-gray-800/60">
          <th class="px-3 py-2 text-sm text-gray-300 border-t border-gray-700">${row.label}</th>`;
        for (let i = 0; i < YV.length; i++) {
          const key = row.seq[i];
          const k = byKey[`${key}|${row.cat}`] || byR[key];
          if (!k) {
            yBody += `
              <td class="px-3 py-3 border-t border-gray-700 text-gray-600">—</td>
              <td class="px-2 py-3 border-t border-gray-700 text-center text-xs text-gray-500">—</td>
              <td class="px-2 py-3 border-t border-gray-700 text-center text-xs text-gray-500">—</td>`;
            continue;
          }
          yBody += `
            <td class="px-3 py-3 border-t border-gray-700 align-middle">
              <div class="flex items-baseline gap-3">
                <div class="text-2xl">${k.h}</div>
                <div class="text-2xl">${k.k}</div>
              </div>
            </td>
            <td class="px-2 py-3 border-t border-gray-700 text-center text-xs"><code>${k.kbd}</code></td>
            <td class="px-2 py-3 border-t border-gray-700 text-center text-xs">
              ${k.r !== k.kbd ? `<code>${k.r}</code>` : '—'}
            </td>`;
        }
        yBody += `</tr>`;
      }
      yBody += `</tbody>`;

      document.getElementById('kanaTable').innerHTML = `
        <table class="min-w-full border border-gray-700 rounded-xl overflow-x-auto text-left mb-6">
          ${mainHead}${mainBody}
        </table>
        <h3 class="text-sm text-gray-300 font-semibold mb-2">Yōon (contracted ya/yu/yo)</h3>
        <table class="min-w-full border border-gray-700 rounded-xl overflow-x-auto text-left">
          ${yHead}${yBody}
        </table>
        <p class="mt-2 text-xs text-gray-500">Tip: IMEs accept multiple spellings. Either <em>kbd</em> (e.g., <code>sya</code>) or <em>phon</em> (e.g., <code>sha</code>) works in typing mode.</p>
      `;
    }

    // Keep canvas crisp on resize when visible
    window.addEventListener('resize', () => {
      try {
        const wrap = document.getElementById('drawWrap');
        if (wrap && !wrap.classList.contains('hidden') && typeof initCanvas === 'function') {
          initCanvas();
        }
      } catch (e) { /* ignore */ }
    });

    // Initialize question max on first load
    updateQuestionLimit(true);
  </script>
</body>

</html>